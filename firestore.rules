rules_version = '2';

/**
 * Firestore Security Rules for E2EE Chat
 *
 * Security Model:
 * - Users can only write their own public key
 * - Users can only read/write messages in conversations they're part of
 * - No rules depend on message content (it's encrypted)
 * - Metadata validation only (sender ID, timestamps, structure)
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // =========================================================================
    // Public Keys Collection
    // Users publish their public keys for key exchange
    // =========================================================================
    match /publicKeys/{userId} {
      // Anyone authenticated can read public keys (needed for key exchange)
      allow read: if request.auth != null;

      // Users can only write their own public key
      allow create, update: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.keys().hasAll(['userId', 'publicKey', 'createdAt'])
        && request.resource.data.userId == userId
        && request.resource.data.publicKey is string
        && request.resource.data.publicKey.size() > 0
        && request.resource.data.createdAt is number;

      // Users can only delete their own public key
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // =========================================================================
    // Conversations Collection
    // Metadata about conversations (participants, timestamps)
    // =========================================================================
    match /conversations/{conversationId} {
      // Helper: check if user ID is in the conversation ID (format: "uid1_uid2")
      function isParticipantById() {
        return request.auth != null
          && (conversationId.matches('.*' + request.auth.uid + '.*'));
      }

      // Helper function to check if user is a participant (for existing docs)
      function isParticipant() {
        return request.auth != null
          && request.auth.uid in resource.data.participants;
      }

      function willBeParticipant() {
        return request.auth != null
          && request.auth.uid in request.resource.data.participants;
      }

      // Allow read if user's UID is in the conversation ID
      allow read: if isParticipantById();

      // Users can create conversations they're part of
      allow create: if request.auth != null
        && willBeParticipant()
        && isParticipantById()
        && request.resource.data.keys().hasAll(['id', 'participants', 'createdAt', 'lastMessageAt'])
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.resource.data.createdAt is number
        && request.resource.data.lastMessageAt is number;

      // Participants can update lastMessageAt
      allow update: if isParticipant();

      // =========================================================================
      // Messages Subcollection
      // Encrypted messages within a conversation
      // =========================================================================
      match /messages/{messageId} {
        // Participants can read messages (user's UID must be in conversation ID)
        allow read: if isParticipantById();

        // Participants can create messages
        allow create: if isParticipantById()
          && request.auth.uid == request.resource.data.senderId
          && request.resource.data.keys().hasAll([
              'senderId',
              'recipientId',
              'senderUsername',
              'conversationId',
              'createdAt',
              'encrypted',
              'messageNonce'
            ])
          // Validate sender is the authenticated user
          && request.resource.data.senderId == request.auth.uid
          // Validate recipient is not the sender
          && request.resource.data.recipientId != request.auth.uid
          // Validate conversation ID matches
          && request.resource.data.conversationId == conversationId
          // Validate timestamp
          && request.resource.data.createdAt is number
          // Validate encrypted payload structure (not content)
          && request.resource.data.encrypted is map
          && request.resource.data.encrypted.keys().hasAll(['ciphertext', 'iv', 'version'])
          && request.resource.data.encrypted.ciphertext is string
          && request.resource.data.encrypted.iv is string
          && request.resource.data.encrypted.version is number
          // Validate nonce exists
          && request.resource.data.messageNonce is string
          && request.resource.data.messageNonce.size() > 0;

        // Messages cannot be updated or deleted (immutable for security)
        allow update, delete: if false;
      }
    }

    // =========================================================================
    // Legacy: Chat Rooms (if keeping old public chat)
    // =========================================================================
    match /chatRooms/{roomId} {
      allow read: if request.auth != null;

      match /messages/{messageId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null;
      }

      match /typingIndicators/{oderId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null;
      }
    }

    // Deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
